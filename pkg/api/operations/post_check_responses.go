// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PostCheckReader is a Reader for the PostCheck structure.
type PostCheckReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PostCheckReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPostCheckOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("[POST /check] PostCheck", response, response.Code())
	}
}

// NewPostCheckOK creates a PostCheckOK with default headers values
func NewPostCheckOK() *PostCheckOK {
	return &PostCheckOK{}
}

/*
PostCheckOK describes a response with status code 200, with default header values.

the result of checking the text
*/
type PostCheckOK struct {
	Payload *PostCheckOKBody
}

// IsSuccess returns true when this post check o k response has a 2xx status code
func (o *PostCheckOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this post check o k response has a 3xx status code
func (o *PostCheckOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post check o k response has a 4xx status code
func (o *PostCheckOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this post check o k response has a 5xx status code
func (o *PostCheckOK) IsServerError() bool {
	return false
}

// IsCode returns true when this post check o k response a status code equal to that given
func (o *PostCheckOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the post check o k response
func (o *PostCheckOK) Code() int {
	return 200
}

func (o *PostCheckOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /check][%d] postCheckOK %s", 200, payload)
}

func (o *PostCheckOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /check][%d] postCheckOK %s", 200, payload)
}

func (o *PostCheckOK) GetPayload() *PostCheckOKBody {
	return o.Payload
}

func (o *PostCheckOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PostCheckOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
PostCheckOKBody post check o k body
swagger:model PostCheckOKBody
*/
type PostCheckOKBody struct {

	// language
	Language *PostCheckOKBodyLanguage `json:"language,omitempty"`

	// matches
	Matches []*PostCheckOKBodyMatchesItems0 `json:"matches"`

	// software
	Software *PostCheckOKBodySoftware `json:"software,omitempty"`
}

// Validate validates this post check o k body
func (o *PostCheckOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSoftware(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBody) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(o.Language) { // not required
		return nil
	}

	if o.Language != nil {
		if err := o.Language.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "language")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "language")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBody) validateMatches(formats strfmt.Registry) error {
	if swag.IsZero(o.Matches) { // not required
		return nil
	}

	for i := 0; i < len(o.Matches); i++ {
		if swag.IsZero(o.Matches[i]) { // not required
			continue
		}

		if o.Matches[i] != nil {
			if err := o.Matches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCheckOK" + "." + "matches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCheckOK" + "." + "matches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PostCheckOKBody) validateSoftware(formats strfmt.Registry) error {
	if swag.IsZero(o.Software) { // not required
		return nil
	}

	if o.Software != nil {
		if err := o.Software.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "software")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post check o k body based on the context it is used
func (o *PostCheckOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLanguage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSoftware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBody) contextValidateLanguage(ctx context.Context, formats strfmt.Registry) error {

	if o.Language != nil {

		if swag.IsZero(o.Language) { // not required
			return nil
		}

		if err := o.Language.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "language")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "language")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBody) contextValidateMatches(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Matches); i++ {

		if o.Matches[i] != nil {

			if swag.IsZero(o.Matches[i]) { // not required
				return nil
			}

			if err := o.Matches[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCheckOK" + "." + "matches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCheckOK" + "." + "matches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PostCheckOKBody) contextValidateSoftware(ctx context.Context, formats strfmt.Registry) error {

	if o.Software != nil {

		if swag.IsZero(o.Software) { // not required
			return nil
		}

		if err := o.Software.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "software")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBody) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyLanguage The language used for checking the text.
swagger:model PostCheckOKBodyLanguage
*/
type PostCheckOKBodyLanguage struct {

	// ISO 639-1 code like 'en', 'en-US', or 'ca-ES-valencia'
	// Required: true
	Code *string `json:"code"`

	// detected language
	// Required: true
	DetectedLanguage *PostCheckOKBodyLanguageDetectedLanguage `json:"detectedLanguage"`

	// Language name like 'French' or 'English (US)'.
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this post check o k body language
func (o *PostCheckOKBodyLanguage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDetectedLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyLanguage) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"language"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyLanguage) validateDetectedLanguage(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"language"+"."+"detectedLanguage", "body", o.DetectedLanguage); err != nil {
		return err
	}

	if o.DetectedLanguage != nil {
		if err := o.DetectedLanguage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "language" + "." + "detectedLanguage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "language" + "." + "detectedLanguage")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyLanguage) validateName(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"language"+"."+"name", "body", o.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post check o k body language based on the context it is used
func (o *PostCheckOKBodyLanguage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetectedLanguage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyLanguage) contextValidateDetectedLanguage(ctx context.Context, formats strfmt.Registry) error {

	if o.DetectedLanguage != nil {

		if err := o.DetectedLanguage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCheckOK" + "." + "language" + "." + "detectedLanguage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCheckOK" + "." + "language" + "." + "detectedLanguage")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyLanguage) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyLanguage) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyLanguage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyLanguageDetectedLanguage The automatically detected text language (might be different from the language actually used for checking).
swagger:model PostCheckOKBodyLanguageDetectedLanguage
*/
type PostCheckOKBodyLanguageDetectedLanguage struct {

	// ISO 639-1 code like 'en', 'en-US', or 'ca-ES-valencia'.
	// Required: true
	Code *string `json:"code"`

	// Language name like 'French' or 'English (US)'.
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this post check o k body language detected language
func (o *PostCheckOKBodyLanguageDetectedLanguage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyLanguageDetectedLanguage) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"language"+"."+"detectedLanguage"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyLanguageDetectedLanguage) validateName(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"language"+"."+"detectedLanguage"+"."+"name", "body", o.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post check o k body language detected language based on context it is used
func (o *PostCheckOKBodyLanguageDetectedLanguage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyLanguageDetectedLanguage) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyLanguageDetectedLanguage) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyLanguageDetectedLanguage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0 post check o k body matches items0
swagger:model PostCheckOKBodyMatchesItems0
*/
type PostCheckOKBodyMatchesItems0 struct {

	// context
	// Required: true
	Context *PostCheckOKBodyMatchesItems0Context `json:"context"`

	// The length of the error in characters.
	// Required: true
	Length *int64 `json:"length"`

	// Message about the error displayed to the user.
	// Required: true
	Message *string `json:"message"`

	// The 0-based character offset of the error in the text.
	// Required: true
	Offset *int64 `json:"offset"`

	// Replacements that might correct the error. The array can be empty, in this case there is no suggested replacement.
	// Required: true
	Replacements []*PostCheckOKBodyMatchesItems0ReplacementsItems0 `json:"replacements"`

	// rule
	Rule *PostCheckOKBodyMatchesItems0Rule `json:"rule,omitempty"`

	// The sentence the error occurred in (since LanguageTool 4.0 or later)
	// Required: true
	Sentence *string `json:"sentence"`

	// An optional shorter version of 'message'.
	ShortMessage string `json:"shortMessage,omitempty"`
}

// Validate validates this post check o k body matches items0
func (o *PostCheckOKBodyMatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContext(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLength(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOffset(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReplacements(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSentence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateContext(formats strfmt.Registry) error {

	if err := validate.Required("context", "body", o.Context); err != nil {
		return err
	}

	if o.Context != nil {
		if err := o.Context.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("context")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("context")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateLength(formats strfmt.Registry) error {

	if err := validate.Required("length", "body", o.Length); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateMessage(formats strfmt.Registry) error {

	if err := validate.Required("message", "body", o.Message); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateOffset(formats strfmt.Registry) error {

	if err := validate.Required("offset", "body", o.Offset); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateReplacements(formats strfmt.Registry) error {

	if err := validate.Required("replacements", "body", o.Replacements); err != nil {
		return err
	}

	for i := 0; i < len(o.Replacements); i++ {
		if swag.IsZero(o.Replacements[i]) { // not required
			continue
		}

		if o.Replacements[i] != nil {
			if err := o.Replacements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("replacements" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("replacements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateRule(formats strfmt.Registry) error {
	if swag.IsZero(o.Rule) { // not required
		return nil
	}

	if o.Rule != nil {
		if err := o.Rule.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rule")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) validateSentence(formats strfmt.Registry) error {

	if err := validate.Required("sentence", "body", o.Sentence); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post check o k body matches items0 based on the context it is used
func (o *PostCheckOKBodyMatchesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReplacements(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyMatchesItems0) contextValidateContext(ctx context.Context, formats strfmt.Registry) error {

	if o.Context != nil {

		if err := o.Context.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("context")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("context")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) contextValidateReplacements(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Replacements); i++ {

		if o.Replacements[i] != nil {

			if swag.IsZero(o.Replacements[i]) { // not required
				return nil
			}

			if err := o.Replacements[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("replacements" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("replacements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0) contextValidateRule(ctx context.Context, formats strfmt.Registry) error {

	if o.Rule != nil {

		if swag.IsZero(o.Rule) { // not required
			return nil
		}

		if err := o.Rule.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rule")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0Context post check o k body matches items0 context
swagger:model PostCheckOKBodyMatchesItems0Context
*/
type PostCheckOKBodyMatchesItems0Context struct {

	// The length of the error in characters in the context.
	// Required: true
	Length *int64 `json:"length"`

	// The 0-based character offset of the error in the context text.
	// Required: true
	Offset *int64 `json:"offset"`

	// Context of the error, i.e. the error and some text to the left and to the left.
	// Required: true
	Text *string `json:"text"`
}

// Validate validates this post check o k body matches items0 context
func (o *PostCheckOKBodyMatchesItems0Context) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLength(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOffset(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateText(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyMatchesItems0Context) validateLength(formats strfmt.Registry) error {

	if err := validate.Required("context"+"."+"length", "body", o.Length); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Context) validateOffset(formats strfmt.Registry) error {

	if err := validate.Required("context"+"."+"offset", "body", o.Offset); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Context) validateText(formats strfmt.Registry) error {

	if err := validate.Required("context"+"."+"text", "body", o.Text); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post check o k body matches items0 context based on context it is used
func (o *PostCheckOKBodyMatchesItems0Context) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0Context) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0Context) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0Context
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0ReplacementsItems0 post check o k body matches items0 replacements items0
swagger:model PostCheckOKBodyMatchesItems0ReplacementsItems0
*/
type PostCheckOKBodyMatchesItems0ReplacementsItems0 struct {

	// the replacement string
	Value string `json:"value,omitempty"`
}

// Validate validates this post check o k body matches items0 replacements items0
func (o *PostCheckOKBodyMatchesItems0ReplacementsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this post check o k body matches items0 replacements items0 based on context it is used
func (o *PostCheckOKBodyMatchesItems0ReplacementsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0ReplacementsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0ReplacementsItems0) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0ReplacementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0Rule post check o k body matches items0 rule
swagger:model PostCheckOKBodyMatchesItems0Rule
*/
type PostCheckOKBodyMatchesItems0Rule struct {

	// category
	// Required: true
	Category *PostCheckOKBodyMatchesItems0RuleCategory `json:"category"`

	// description
	// Required: true
	Description *string `json:"description"`

	// An rule's identifier that's unique for this language.
	// Required: true
	ID *string `json:"id"`

	// The <a href="http://www.w3.org/International/multilingualweb/lt/drafts/its20/its20.html#lqissue-typevalues">Localization Quality Issue Type</a>. This is not defined for all languages, in which case it will always be 'Uncategorized'.
	IssueType string `json:"issueType,omitempty"`

	// An optional sub identifier of the rule, used when several rules are grouped.
	SubID string `json:"subId,omitempty"`

	// An optional array of URLs with a more detailed description of the error.
	Urls []*PostCheckOKBodyMatchesItems0RuleUrlsItems0 `json:"urls"`
}

// Validate validates this post check o k body matches items0 rule
func (o *PostCheckOKBodyMatchesItems0Rule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUrls(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) validateCategory(formats strfmt.Registry) error {

	if err := validate.Required("rule"+"."+"category", "body", o.Category); err != nil {
		return err
	}

	if o.Category != nil {
		if err := o.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rule" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rule" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("rule"+"."+"description", "body", o.Description); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) validateID(formats strfmt.Registry) error {

	if err := validate.Required("rule"+"."+"id", "body", o.ID); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) validateUrls(formats strfmt.Registry) error {
	if swag.IsZero(o.Urls) { // not required
		return nil
	}

	for i := 0; i < len(o.Urls); i++ {
		if swag.IsZero(o.Urls[i]) { // not required
			continue
		}

		if o.Urls[i] != nil {
			if err := o.Urls[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + "urls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rule" + "." + "urls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post check o k body matches items0 rule based on the context it is used
func (o *PostCheckOKBodyMatchesItems0Rule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateUrls(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if o.Category != nil {

		if err := o.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rule" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rule" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (o *PostCheckOKBodyMatchesItems0Rule) contextValidateUrls(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Urls); i++ {

		if o.Urls[i] != nil {

			if swag.IsZero(o.Urls[i]) { // not required
				return nil
			}

			if err := o.Urls[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + "urls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rule" + "." + "urls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0Rule) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0Rule) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0Rule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0RuleCategory post check o k body matches items0 rule category
swagger:model PostCheckOKBodyMatchesItems0RuleCategory
*/
type PostCheckOKBodyMatchesItems0RuleCategory struct {

	// A category's identifier that's unique for this language.
	ID string `json:"id,omitempty"`

	// A short description of the category.
	Name string `json:"name,omitempty"`
}

// Validate validates this post check o k body matches items0 rule category
func (o *PostCheckOKBodyMatchesItems0RuleCategory) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this post check o k body matches items0 rule category based on context it is used
func (o *PostCheckOKBodyMatchesItems0RuleCategory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0RuleCategory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0RuleCategory) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0RuleCategory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodyMatchesItems0RuleUrlsItems0 post check o k body matches items0 rule urls items0
swagger:model PostCheckOKBodyMatchesItems0RuleUrlsItems0
*/
type PostCheckOKBodyMatchesItems0RuleUrlsItems0 struct {

	// the URL
	Value string `json:"value,omitempty"`
}

// Validate validates this post check o k body matches items0 rule urls items0
func (o *PostCheckOKBodyMatchesItems0RuleUrlsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this post check o k body matches items0 rule urls items0 based on context it is used
func (o *PostCheckOKBodyMatchesItems0RuleUrlsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0RuleUrlsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodyMatchesItems0RuleUrlsItems0) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodyMatchesItems0RuleUrlsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCheckOKBodySoftware post check o k body software
swagger:model PostCheckOKBodySoftware
*/
type PostCheckOKBodySoftware struct {

	// Version of this API response. We don't expect to make incompatible changes, so this can also be increased for newly added fields.
	// Required: true
	APIVersion *int64 `json:"apiVersion"`

	// Date when the software was built, e.g. '2016-05-25'.
	// Required: true
	BuildDate *string `json:"buildDate"`

	// Usually 'LanguageTool'.
	// Required: true
	Name *string `json:"name"`

	// true if you're using a Premium account with all the premium text checks (since LanguageTool 4.2)
	Premium bool `json:"premium,omitempty"`

	// An optional warning, e.g. when the API format is not stable.
	Status string `json:"status,omitempty"`

	// A version string like '3.3' or '3.4-SNAPSHOT'.
	// Required: true
	Version *string `json:"version"`
}

// Validate validates this post check o k body software
func (o *PostCheckOKBodySoftware) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAPIVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCheckOKBodySoftware) validateAPIVersion(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"software"+"."+"apiVersion", "body", o.APIVersion); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodySoftware) validateBuildDate(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"software"+"."+"buildDate", "body", o.BuildDate); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodySoftware) validateName(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"software"+"."+"name", "body", o.Name); err != nil {
		return err
	}

	return nil
}

func (o *PostCheckOKBodySoftware) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("postCheckOK"+"."+"software"+"."+"version", "body", o.Version); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post check o k body software based on context it is used
func (o *PostCheckOKBodySoftware) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCheckOKBodySoftware) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCheckOKBodySoftware) UnmarshalBinary(b []byte) error {
	var res PostCheckOKBodySoftware
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
